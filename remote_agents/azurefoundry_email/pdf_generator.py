"""
PDF Report Generator with Cay Digital Branding
===============================================

Generates branded PDF reports using the Cay Digital visual identity.
"""
import os
import re
import html
import tempfile
from datetime import datetime
from typing import Optional

# Try to import fpdf2, fall back gracefully
try:
    from fpdf import FPDF
    PDF_AVAILABLE = True
except ImportError:
    PDF_AVAILABLE = False
    FPDF = None

# Cay Digital Brand Colors
BRAND_COLORS = {
    "dark_bg": (26, 26, 26),        # #1a1a1a - Dark background
    "accent_green": (0, 255, 102),   # #00FF66 - Neon green accent
    "white": (255, 255, 255),        # White text
    "light_gray": (180, 180, 180),   # Light gray for secondary text
    "dark_gray": (40, 40, 40),       # Slightly lighter than bg for sections
}


class CayDigitalPDF(FPDF if FPDF else object):
    """Custom PDF class with Cay Digital branding."""
    
    def __init__(self, logo_path: Optional[str] = None):
        if not PDF_AVAILABLE:
            raise ImportError("fpdf2 is required for PDF generation. Install with: pip install fpdf2")
        super().__init__()
        self.logo_path = logo_path or self._find_logo()
        self.set_auto_page_break(auto=True, margin=25)
        
    def _find_logo(self) -> Optional[str]:
        """Find the Cay Digital logo in common locations."""
        possible_paths = [
            os.path.join(os.path.dirname(__file__), "cay_logo.png"),
            os.path.join(os.path.dirname(__file__), "assets", "cay_logo.png"),
            "cay_logo.png",
        ]
        for path in possible_paths:
            if os.path.exists(path):
                return path
        return None
    
    def header(self):
        """Add branded header to each page."""
        # Dark header background
        self.set_fill_color(*BRAND_COLORS["dark_bg"])
        self.rect(0, 0, 210, 35, 'F')
        
        # Green accent bar
        self.set_fill_color(*BRAND_COLORS["accent_green"])
        self.rect(0, 35, 210, 2, 'F')
        
        # Logo (if available)
        if self.logo_path and os.path.exists(self.logo_path):
            try:
                self.image(self.logo_path, 10, 8, 40)
            except Exception:
                # Fallback to text if logo fails
                self.set_text_color(*BRAND_COLORS["white"])
                self.set_font("Helvetica", "B", 16)
                self.set_xy(10, 12)
                self.cell(0, 10, "CAY DIGITAL", ln=False)
        else:
            # Text fallback
            self.set_text_color(*BRAND_COLORS["accent_green"])
            self.set_font("Helvetica", "B", 18)
            self.set_xy(10, 12)
            self.cell(0, 10, "CAY", ln=False)
            self.set_text_color(*BRAND_COLORS["white"])
            self.cell(0, 10, " DIGITAL", ln=False)
        
        # Tagline
        self.set_text_color(*BRAND_COLORS["light_gray"])
        self.set_font("Helvetica", "I", 8)
        self.set_xy(10, 24)
        self.cell(0, 5, "Strategic Advisory for the AI Era", ln=True)
        
        # Reset position after header
        self.set_y(45)
    
    def footer(self):
        """Add branded footer to each page."""
        self.set_y(-20)
        
        # Footer background
        self.set_fill_color(*BRAND_COLORS["dark_bg"])
        self.rect(0, self.get_y(), 210, 25, 'F')
        
        # Green accent bar
        self.set_fill_color(*BRAND_COLORS["accent_green"])
        self.rect(0, self.get_y(), 210, 1, 'F')
        
        # Footer text
        self.set_y(-15)
        self.set_text_color(*BRAND_COLORS["light_gray"])
        self.set_font("Helvetica", "I", 8)
        self.cell(0, 5, f"Generated by Cay Digital AI | {datetime.now().strftime('%B %d, %Y')}", align="C")
        
        # Page number
        self.set_y(-10)
        self.cell(0, 5, f"Page {self.page_no()}", align="C")
    
    def add_title(self, title: str):
        """Add a main title."""
        self.set_text_color(*BRAND_COLORS["dark_bg"])
        self.set_font("Helvetica", "B", 24)
        self.multi_cell(0, 12, title, align="C")
        self.ln(5)
    
    def add_subtitle(self, subtitle: str):
        """Add a subtitle."""
        self.set_text_color(*BRAND_COLORS["light_gray"])
        self.set_font("Helvetica", "I", 12)
        self.multi_cell(0, 8, subtitle, align="C")
        self.ln(10)
    
    def add_section(self, title: str, content: str):
        """Add a section with title and content."""
        # Section title with green accent
        self.set_fill_color(*BRAND_COLORS["accent_green"])
        self.rect(10, self.get_y(), 3, 8, 'F')
        
        self.set_x(18)
        self.set_text_color(*BRAND_COLORS["dark_bg"])
        self.set_font("Helvetica", "B", 14)
        self.cell(0, 8, title, ln=True)
        self.ln(3)
        
        # Section content
        self.set_text_color(60, 60, 60)
        self.set_font("Helvetica", "", 11)
        self.set_x(10)
        self.multi_cell(190, 6, content)
        self.ln(8)
    
    def add_bullet_list(self, title: str, items: list):
        """Add a bulleted list section."""
        # Section title
        self.set_fill_color(*BRAND_COLORS["accent_green"])
        self.rect(10, self.get_y(), 3, 8, 'F')
        
        self.set_x(18)
        self.set_text_color(*BRAND_COLORS["dark_bg"])
        self.set_font("Helvetica", "B", 14)
        self.cell(0, 8, title, ln=True)
        self.ln(3)
        
        # Bullet items
        self.set_text_color(60, 60, 60)
        self.set_font("Helvetica", "", 11)
        for item in items:
            self.set_x(15)
            self.set_text_color(*BRAND_COLORS["accent_green"])
            self.cell(5, 6, chr(149), ln=False)  # Bullet character
            self.set_text_color(60, 60, 60)
            self.multi_cell(180, 6, item)
        self.ln(5)
    
    def add_info_box(self, title: str, info: dict):
        """Add an information box with key-value pairs."""
        # Box background
        start_y = self.get_y()
        self.set_fill_color(245, 245, 245)
        
        # Calculate height needed
        self.set_font("Helvetica", "", 10)
        height = 15 + (len(info) * 8)
        
        self.rect(10, start_y, 190, height, 'F')
        
        # Green top border
        self.set_fill_color(*BRAND_COLORS["accent_green"])
        self.rect(10, start_y, 190, 2, 'F')
        
        # Title
        self.set_xy(15, start_y + 5)
        self.set_text_color(*BRAND_COLORS["dark_bg"])
        self.set_font("Helvetica", "B", 11)
        self.cell(0, 6, title, ln=True)
        
        # Info items
        self.set_font("Helvetica", "", 10)
        for key, value in info.items():
            self.set_x(15)
            self.set_text_color(*BRAND_COLORS["dark_bg"])
            self.set_font("Helvetica", "B", 10)
            self.cell(40, 6, f"{key}:", ln=False)
            self.set_font("Helvetica", "", 10)
            self.set_text_color(80, 80, 80)
            self.cell(0, 6, str(value), ln=True)
        
        self.set_y(start_y + height + 10)


def normalize_text_for_pdf(text: str) -> str:
    """Normalize text for PDF generation - remove emojis and fix special characters."""
    # Replace curly quotes with straight quotes
    replacements = {
        '\u2018': "'",  # Left single quote
        '\u2019': "'",  # Right single quote (apostrophe)
        '\u201C': '"',  # Left double quote
        '\u201D': '"',  # Right double quote
        '\u2013': '-',  # En dash
        '\u2014': '-',  # Em dash
        '\u2026': '...',  # Ellipsis
        '\u00A0': ' ',  # Non-breaking space
        '\u2022': '*',  # Bullet
        '\u00B7': '*',  # Middle dot
        '\u2212': '-',  # Minus sign
        '\u00D7': 'x',  # Multiplication sign
        '\u00F7': '/',  # Division sign
        '\u2192': '->',  # Right arrow
        '\u2190': '<-',  # Left arrow
        '\u2194': '<->',  # Left-right arrow
        '\u2713': '[x]',  # Check mark
        '\u2717': '[ ]',  # X mark
        '\u2610': '[ ]',  # Ballot box
        '\u2611': '[x]',  # Ballot box with check
        '\u2612': '[x]',  # Ballot box with X
    }
    
    for old, new in replacements.items():
        text = text.replace(old, new)
    
    # Remove common emoji ranges
    emoji_pattern = re.compile(
        "["
        "\U0001F600-\U0001F64F"  # emoticons
        "\U0001F300-\U0001F5FF"  # symbols & pictographs
        "\U0001F680-\U0001F6FF"  # transport & map symbols
        "\U0001F1E0-\U0001F1FF"  # flags
        "\U00002702-\U000027B0"  # dingbats
        "\U000024C2-\U0001F251"  # enclosed characters
        "\U0001F900-\U0001F9FF"  # supplemental symbols
        "\U00002600-\U000026FF"  # misc symbols
        "\U00002700-\U000027BF"  # dingbats
        "\U0001FA00-\U0001FA6F"  # chess symbols
        "\U0001FA70-\U0001FAFF"  # symbols extended
        "\U00002300-\U000023FF"  # misc technical
        "]+", 
        flags=re.UNICODE
    )
    text = emoji_pattern.sub('', text)
    
    # Remove any remaining non-ASCII characters that might cause issues
    # but keep common accented characters
    result = []
    for char in text:
        if ord(char) < 128:  # ASCII
            result.append(char)
        elif ord(char) in range(0x00C0, 0x00FF):  # Latin-1 Supplement (accents)
            result.append(char)
        else:
            result.append('')  # Skip other Unicode
    
    return ''.join(result)


def strip_html(html_content: str) -> str:
    """Strip HTML tags, decode entities, and normalize for PDF."""
    # Remove HTML tags
    clean = re.sub(r'<[^>]+>', '\n', html_content)
    # Decode HTML entities
    clean = html.unescape(clean)
    # Normalize text for PDF (remove emojis, fix quotes, etc.)
    clean = normalize_text_for_pdf(clean)
    # Normalize whitespace
    clean = re.sub(r'\n\s*\n', '\n\n', clean)
    clean = re.sub(r' +', ' ', clean)
    return clean.strip()


def parse_report_content(report_text: str) -> dict:
    """Parse report content into structured sections."""
    sections = {
        "title": "AI Consultation Report",
        "subtitle": f"Prepared by Cay Digital | {datetime.now().strftime('%B %d, %Y')}",
        "sections": []
    }
    
    # Try to extract title from the first heading
    title_match = re.search(r'^#\s*(.+?)$|^##\s*(.+?)$|<h[12]>(.+?)</h[12]>', report_text, re.MULTILINE | re.IGNORECASE)
    if title_match:
        title = title_match.group(1) or title_match.group(2) or title_match.group(3)
        sections["title"] = normalize_text_for_pdf(title).strip()
    
    # Strip HTML and emojis for processing
    clean_text = strip_html(report_text)
    
    # Split by common section headers
    section_patterns = [
        r'(?:^|\n)#+\s*(.+?)(?:\n|$)',  # Markdown headers
        r'(?:^|\n)([A-Z][A-Z\s]+:)',     # UPPERCASE HEADERS:
        r'(?:^|\n)\*\*(.+?)\*\*',         # **Bold headers**
    ]
    
    # Simple approach: split into paragraphs and group
    paragraphs = [p.strip() for p in clean_text.split('\n\n') if p.strip()]
    
    current_section = {"title": "Overview", "content": []}
    
    for para in paragraphs:
        # Check if it looks like a header
        if len(para) < 60 and (para.isupper() or para.endswith(':') or para.startswith('#')):
            if current_section["content"]:
                sections["sections"].append(current_section)
            # Clean the section title
            section_title = normalize_text_for_pdf(para.strip('#: ')).strip()
            current_section = {"title": section_title or "Section", "content": []}
        else:
            current_section["content"].append(para)
    
    if current_section["content"]:
        sections["sections"].append(current_section)
    
    return sections


def generate_report_pdf(
    report_content: str,
    recipient_name: str = "",
    recipient_email: str = "",
    company_name: str = "",
    output_path: Optional[str] = None
) -> str:
    """
    Generate a branded PDF report.
    
    Args:
        report_content: The report content (HTML or plain text)
        recipient_name: Name of the recipient
        recipient_email: Email of the recipient
        company_name: Company name of the recipient
        output_path: Optional path to save the PDF (uses temp file if not provided)
    
    Returns:
        Path to the generated PDF file
    """
    if not PDF_AVAILABLE:
        raise ImportError("fpdf2 is required for PDF generation. Install with: pip install fpdf2")
    
    pdf = CayDigitalPDF()
    pdf.add_page()
    
    # Parse the report content
    parsed = parse_report_content(report_content)
    
    # Add title
    pdf.add_title(parsed["title"])
    pdf.add_subtitle(parsed["subtitle"])
    
    # Add recipient info box if available
    if recipient_name or recipient_email or company_name:
        info = {}
        if recipient_name:
            info["Prepared For"] = recipient_name
        if company_name:
            info["Company"] = company_name
        if recipient_email:
            info["Email"] = recipient_email
        info["Date"] = datetime.now().strftime("%B %d, %Y")
        pdf.add_info_box("Report Details", info)
    
    # Add content sections
    for section in parsed["sections"]:
        content = "\n\n".join(section["content"])
        if content:
            pdf.add_section(section["title"], content)
    
    # Determine output path
    if not output_path:
        # Create temp file
        fd, output_path = tempfile.mkstemp(suffix=".pdf", prefix="cay_report_")
        os.close(fd)
    
    # Save PDF
    pdf.output(output_path)
    
    return output_path


def is_pdf_available() -> bool:
    """Check if PDF generation is available."""
    return PDF_AVAILABLE

