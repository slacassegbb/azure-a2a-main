"""
Agent File Registry - Tracks files generated by remote agents per session.

When a remote agent generates a file (like an image), it uploads to blob storage
at a generic path like `image-generator/{uuid}/filename.png`. The host backend
needs to associate that file with the user's session so it shows up in their
file history.

This registry provides:
1. Database storage (PostgreSQL) with JSON fallback for local dev
2. Methods to register new files and list files for a session
3. Thread-safe operations with connection pooling
"""

import json
import os
import threading
import uuid
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional
import psycopg2
from psycopg2.extras import RealDictCursor

# Thread lock for safe concurrent access
_lock = threading.Lock()

# In-memory registry for JSON fallback: {session_id: [file_records]}
_registry: Dict[str, List[Dict[str, Any]]] = {}

# Directory for persisting the registry (JSON fallback)
REGISTRY_DIR = Path(__file__).resolve().parent.parent / "data"
REGISTRY_FILE = REGISTRY_DIR / "agent_files_registry.json"

# Database connection
DATABASE_URL = os.getenv('DATABASE_URL')
_db_conn = None
_use_database = False

def _get_db_connection():
    """Get a working database connection, reconnecting if needed."""
    global _db_conn, _use_database
    
    if not DATABASE_URL:
        return None
    
    try:
        # Check if connection is still alive
        if _db_conn:
            try:
                _db_conn.cursor().execute("SELECT 1")
            except:
                # Connection is dead, reconnect
                print("[AgentFileRegistry] ðŸ”„ Reconnecting to database...")
                try:
                    _db_conn.close()
                except:
                    pass
                _db_conn = None
        
        if not _db_conn:
            _db_conn = psycopg2.connect(DATABASE_URL)
            _db_conn.autocommit = False
            _use_database = True
            print("[AgentFileRegistry] âœ… Connected to PostgreSQL database")
        
        return _db_conn
    except Exception as e:
        print(f"[AgentFileRegistry] âŒ Database connection failed: {e}")
        _use_database = False
        return None

def _init_database():
    """Initialize database connection if DATABASE_URL is available."""
    global _db_conn, _use_database
    
    if DATABASE_URL:
        try:
            _db_conn = psycopg2.connect(DATABASE_URL)
            _use_database = True
            print("[AgentFileRegistry] âœ… Using PostgreSQL database")
        except Exception as e:
            print(f"[AgentFileRegistry] âŒ Failed to connect to database: {e}")
            _use_database = False
    else:
        print("[AgentFileRegistry] âš ï¸ DATABASE_URL not set, using JSON file fallback")


def _load_registry():
    """Load registry from database or disk on startup."""
    global _registry
    
    if _use_database and _db_conn:
        # When using database, we don't load all files into memory
        # Files are queried on-demand via get_agent_files()
        _registry = {}
        print("[AgentFileRegistry] Files will be queried from database on-demand")
    else:
        # Fallback to JSON file
        try:
            if REGISTRY_FILE.exists():
                with open(REGISTRY_FILE, 'r') as f:
                    _registry = json.load(f)
                    print(f"[AgentFileRegistry] Loaded {sum(len(v) for v in _registry.values())} files for {len(_registry)} sessions from file")
        except Exception as e:
            print(f"[AgentFileRegistry] Failed to load registry: {e}")
            _registry = {}


def _save_registry():
    """Persist registry to disk (JSON fallback only)."""
    try:
        REGISTRY_DIR.mkdir(parents=True, exist_ok=True)
        with open(REGISTRY_FILE, 'w') as f:
            json.dump(_registry, f, indent=2, default=str)
    except Exception as e:
        print(f"[AgentFileRegistry] Failed to save registry: {e}")


def _save_to_database(file_record: Dict[str, Any], session_id: str):
    """Save file record to database."""
    db_conn = _get_db_connection()
    if not db_conn:
        return
    
    try:
        cur = db_conn.cursor()
        
        # Parse uploaded_at datetime
        uploaded_at = file_record.get('uploadedAt')
        if isinstance(uploaded_at, str):
            uploaded_at = datetime.fromisoformat(uploaded_at.replace('Z', '+00:00'))
        
        # Insert into database (UPSERT)
        cur.execute("""
            INSERT INTO agent_files (
                id, session_id, filename, original_name, size,
                content_type, uploaded_at, uri, source_agent, file_type
            ) VALUES (
                %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
            )
            ON CONFLICT (id) DO UPDATE SET
                filename = EXCLUDED.filename,
                uri = EXCLUDED.uri,
                uploaded_at = EXCLUDED.uploaded_at
        """, (
            file_record['id'],
            session_id,
            file_record['filename'],
            file_record.get('originalName', file_record['filename']),
            file_record.get('size', 0),
            file_record.get('contentType', 'application/octet-stream'),
            uploaded_at,
            file_record['uri'],
            file_record.get('sourceAgent'),
            file_record.get('type', 'agent_generated')
        ))
        
        db_conn.commit()
        cur.close()
    except Exception as e:
        print(f"[AgentFileRegistry] Error saving to database: {e}")
        if db_conn:
            db_conn.rollback()



def register_agent_file(
    session_id: str,
    uri: str,
    filename: str,
    content_type: str = "application/octet-stream",
    size: int = 0,
    source_agent: Optional[str] = None,
    file_id: Optional[str] = None
) -> Dict[str, Any]:
    """
    Register a file generated by a remote agent for a session.
    
    Args:
        session_id: The user's session ID
        file_id: Unique ID for this file
        filename: The filename
        uri: The blob storage URI (with SAS token)
        content_type: MIME type
        size: File size in bytes
        source_agent: Name of the agent that generated the file
        
    Returns:
        The created file record
    """
    with _lock:
        # Generate file_id if not provided
        actual_file_id = file_id or str(uuid.uuid4())
        
        # Check for duplicates by URI (strip query params to compare base URL) OR by filename
        base_uri = uri.split('?')[0] if '?' in uri else uri
        
        # Use connection helper for reliable database access
        db_conn = _get_db_connection()
        
        if _use_database and db_conn:
            # Check database for existing file by URI or filename
            try:
                cur = db_conn.cursor(cursor_factory=RealDictCursor)
                # Check by base URI OR exact filename (for same session)
                cur.execute("""
                    SELECT * FROM agent_files 
                    WHERE session_id = %s AND (uri LIKE %s OR filename = %s)
                    LIMIT 1
                """, (session_id, f"{base_uri}%", filename))
                existing = cur.fetchone()
                cur.close()
                
                if existing:
                    print(f"[AgentFileRegistry] File already registered in database: {filename}")
                    return dict(existing)
            except Exception as e:
                print(f"[AgentFileRegistry] Error checking for duplicate: {e}")
        else:
            # Check in-memory registry
            if session_id not in _registry:
                _registry[session_id] = []
            
            # Check by URI base or filename
            existing = next((f for f in _registry[session_id] 
                           if f.get('uri', '').split('?')[0] == base_uri or f.get('filename') == filename), None)
            if existing:
                print(f"[AgentFileRegistry] File already registered: {filename}")
                return existing
        
        file_record = {
            "id": actual_file_id,
            "filename": filename,
            "originalName": filename,
            "size": size,
            "contentType": content_type,
            "uploadedAt": datetime.utcnow().isoformat(),
            "uri": uri,
            "sourceAgent": source_agent,
            "type": "agent_generated"
        }
        
        if _use_database:
            _save_to_database(file_record, session_id)
        else:
            _registry[session_id].append(file_record)
            _save_registry()
        
        print(f"[AgentFileRegistry] Registered file for session {session_id[:8]}...: {filename}")
        
        return file_record


def get_agent_files(session_id: str) -> List[Dict[str, Any]]:
    """
    Get all agent-generated files for a session (deduplicated by filename).
    
    Args:
        session_id: The user's session ID
        
    Returns:
        List of file records (unique by filename, most recent first)
    """
    with _lock:
        db_conn = _get_db_connection()
        if _use_database and db_conn:
            # Query from database - use DISTINCT ON to get only one record per filename
            try:
                cur = db_conn.cursor(cursor_factory=RealDictCursor)
                # Use DISTINCT ON (filename) to get only the most recent record per filename
                cur.execute("""
                    SELECT DISTINCT ON (filename) *
                    FROM agent_files
                    WHERE session_id = %s
                    ORDER BY filename, uploaded_at DESC
                """, (session_id,))
                
                rows = cur.fetchall()
                cur.close()
                
                # Convert to list of dicts with correct key names
                files = []
                for row in rows:
                    file_record = {
                        "id": str(row['id']),
                        "filename": row['filename'],
                        "originalName": row['original_name'],
                        "size": row['size'],
                        "contentType": row['content_type'],
                        "uploadedAt": row['uploaded_at'].isoformat() if row['uploaded_at'] else None,
                        "uri": row['uri'],
                        "sourceAgent": row['source_agent'],
                        "type": row['file_type']
                    }
                    files.append(file_record)
                
                return files
                
            except Exception as e:
                print(f"[AgentFileRegistry] Error querying files from database: {e}")
                return []
        else:
            # Return from in-memory registry
            return list(_registry.get(session_id, []))


def clear_session_files(session_id: str) -> int:
    """
    Clear all agent files for a session.
    
    Args:
        session_id: The user's session ID
        
    Returns:
        Number of files cleared
    """
    with _lock:
        if _use_database and _db_conn:
            # Delete from database
            try:
                cur = _db_conn.cursor()
                cur.execute("DELETE FROM agent_files WHERE session_id = %s", (session_id,))
                count = cur.rowcount
                _db_conn.commit()
                cur.close()
                # Also clear from in-memory cache
                if session_id in _registry:
                    del _registry[session_id]
                return count
            except Exception as e:
                print(f"[AgentFileRegistry] Error deleting files from database: {e}")
                _db_conn.rollback()
                return 0
        else:
            # Fallback to JSON file
            count = len(_registry.get(session_id, []))
            if session_id in _registry:
                del _registry[session_id]
                _save_registry()
            return count


def delete_agent_file(session_id: str, file_id: str) -> bool:
    """
    Delete a specific file from the agent file registry.
    
    Args:
        session_id: The user's session ID
        file_id: The ID of the file to delete
        
    Returns:
        True if file was deleted, False otherwise
    """
    with _lock:
        if _use_database and _db_conn:
            # Delete from database
            try:
                cur = _db_conn.cursor()
                cur.execute("DELETE FROM agent_files WHERE session_id = %s AND id = %s", (session_id, file_id))
                deleted = cur.rowcount > 0
                _db_conn.commit()
                cur.close()
                
                # Also remove from in-memory cache if present
                if session_id in _registry:
                    _registry[session_id] = [f for f in _registry[session_id] if f.get('id') != file_id]
                
                if deleted:
                    print(f"[AgentFileRegistry] Deleted file {file_id} from database")
                return deleted
            except Exception as e:
                print(f"[AgentFileRegistry] Error deleting file from database: {e}")
                _db_conn.rollback()
                return False
        else:
            # Fallback to JSON file
            if session_id in _registry:
                original_count = len(_registry[session_id])
                _registry[session_id] = [f for f in _registry[session_id] if f.get('id') != file_id]
                deleted = len(_registry[session_id]) < original_count
                if deleted:
                    _save_registry()
                    print(f"[AgentFileRegistry] Deleted file {file_id} from JSON registry")
                return deleted
            return False


def get_all_sessions() -> List[str]:
    """Get all session IDs that have registered files."""
    with _lock:
        if _use_database and _db_conn:
            # Query from database
            try:
                cur = _db_conn.cursor()
                cur.execute("SELECT DISTINCT session_id FROM agent_files")
                rows = cur.fetchall()
                cur.close()
                return [row[0] for row in rows]
            except Exception as e:
                print(f"[AgentFileRegistry] Error querying sessions: {e}")
                return []
        else:
            return list(_registry.keys())


# Initialize database connection and load registry on module import
_init_database()
_load_registry()
